
<!-- saved from url=(0037)http://kias.dyndns.org/comath/13.html -->
<html hola_ext_inject="ready"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Unsigned and Signed Integers </title>
</head>
<body bgcolor="#fff0e0" hola-ext-player="1">
<h1>Unsigned and Signed Integers </h1>
<p>
An integer is a number with no fractional part; it can be positive, negative or zero. In ordinary usage, 
one uses a minus sign to designate a negative integer. However, a computer can only store information in 
<a href="http://kias.dyndns.org/comath/11.html#bit">bits</a>, which can only have the values zero or one. We might expect, therefore, 
that the storage of negative 
integers in a computer might require some special technique. It is for that reason that we began this section 
with a discussion of unsigned integers. 
 </p><p>
<a name="uint">
As you might imagine, an <b>unsigned integer</b> is either positive or zero. Given our discussion in the previous 
sections about </a><a href="http://kias.dyndns.org/comath/11.html#binary">binary numbers</a>, it might seem that there is little more to say about 
unsigned integers. In 
fact, there is essentially only one thing, and that is one of the most important things that you will learn 
in this text. Consider a single digit decimal number: in a single decimal digit, you can write a number 
between 0 and 9. In two decimal digits, you can write a number between 0 and 99, and so on. Since nine is 
equivalent to 10<sup>1</sup> - 1, 99 is equivalent to 10<sup>2</sup> - 1, etc., in n decimal digits, you can 
write a number between 0 and 10<sup>n</sup> - 1. Analogously, in the binary number system, 
</p><blockquote>
<b>an unsigned integer containing n bits can have a value between 0 and 2<sup>n</sup> - 1<br>
(which is 2<sup>n</sup> different values</b>).
</blockquote>
 This fact is one of the most important and useful things to know about computers. When a computer 
program is written, the programmer, either explicitly or implicitly, must decide how many bits are used 
to store any given quantity. Once the decision is made to use n bits to store it, the program has an inherent 
limitation: that 
quantity can only have a value between 0 and 2<sup>n</sup> - 1. You will meet these limitations in one 
form or another in every piece of hardware and software that you will learn about during your career: 
<a name="bios">
<blockquote>
<ul>
<li>the BIOS (Basic Input Output Software) in older PCs uses 10 bits to store the cylinder number on the 
hard drive where your operating system begins; therefore those PCs cannot boot an operating system from a 
cylinder greater than 2<sup>10</sup> - 1, or 1023.</li><p>
</p><li>a FAT16 file system (used on some flash drives), which allocates file space in units called "clusters", 
uses 16 bits to store cluster 
numbers; therefore there can be no more than 2<sup>16</sup> or 65,536  clusters in such a file system.
<blockquote>
This implies that for a 1 GB flash drive with a FAT16 file system, every file takes up a multiple of 16,384 bytes (2<sup>30</sup>/2<sup>16</sup>),
<i>independent of how much data it contains</i>.
</blockquote>
</li><p>
</p><li>a UNIX system keeps track of the processes (programs) it runs using a PID (Process IDentifier);
for typical memory sizes, the PID is 16 bits long and so 
after 2<sup>16</sup> - 1 or 65,535 processes, the PIDs must start over at the lowest number not 
currently in use.
</li><p>
</p><li>"32-bit software" is restricted to 2<sup>32</sup> <b>virtual memory addresses</b> per process, while "64-bit software"
has 2<sup>64</sup> (18,446,744,073,709,551,616) addresses available.
</li></ul></blockquote>
 These are just a few examples of this basic principle that you will meet in your future studies. 
 </a><p><a name="bios">
</a><a name="byte"></a><a name="short"></a><a name="long"></a><a name="double"></a><a name="octet">
Most modern computers store memory in units of 8 bits, called a "<b>byte</b>" 
(also called an "<b>octet</b>"). Arithmetic in such computers 
can be done in bytes, but is more often done in larger units called "<b>(short) integers</b>" (16 bits), 
"<b>long integers</b>" (32 bits) or "<b>double integers</b>" (64 bits). Short integers can be used to 
store numbers between 0 and 2<sup>16</sup> - 1, or 65,535. Long integers can be used to store numbers 
between 0 and 2<sup>32</sup> - 1, or 4,294,967,295. and double integers can be used to store numbers 
between 0 and 2<sup>64</sup> - 1, or 18,446,744,073,709,551,615. (Check these!)
</a></p><p><a name="octet">
When a computer performs an unsigned integer arithmetic operation, there are three possible problems which 
can occur:
</a></p><blockquote><a name="octet">
</a><ol><a name="octet"></a><a name="oflow">
<li>if the result is too large to fit into the number of bits assigned to it, an "<b>overflow</b>" is said to have 
occurred. For example if the result of an operation using 16 bit integers is larger than 65,535, an 
overflow results.</li></a><p><a name="oflow">
</a><a name="trunc">
</a></p><li><a name="trunc">in the division of two integers, if the result is not itself an integer, a "<b>truncation</b>" is said 
to have occurred: 10 divided by 3 is truncated to 3, and the extra 1/3 is lost. This is not a problem,
of course, if the programmer's intention was to ignore the remainder!</a></li><p><a name="trunc">
</a></p><li><a name="trunc">any division by zero is an error, since division by zero is not possible in the context of arithmetic.</a></li><a name="trunc">
</a></ol></blockquote><a name="trunc">
</a><p><a name="trunc">
</a><a name="sint">
<br>
<br>
</a></p><h3><a name="sint">Signed Integers</a></h3><a name="sint">
</a><a name="sbit">
<b>Signed integers</b> are stored in a computer using </a><a href="http://kias.dyndns.org/comath/12.html#2c">2's complement</a>. As you recall, 
when computing the 2's 
complement of a number it was necessary to know how many bits were to be used in the final result; 
<a href="http://kias.dyndns.org/comath/11.html#lzero">leading 
zeroes</a> were appended to the 
<a href="http://kias.dyndns.org/comath/11.html#msd">most significant digit</a> in order to make the number the appropriate length. Since 
the process of computing the 2's complement involves first computing the 
<a href="http://kias.dyndns.org/comath/12.html#1c">1's complement</a>, these leading zeros 
become leading ones, and the left most bit of a negative number is therefore always 1. In computers, the left 
most bit of a signed integer is called the "<b>sign bit</b>". 
<p>
Consider an 8 bit signed integer: let us begin with 0 0 0 0 0 0 0 0<sub>2</sub> and start counting by repeatedly 
adding 1:
</p><blockquote>
<ul>
<li>When you get to 127, the integer has a value of 0 1 1 1 1 1 1 1<sub>2</sub>; this is easy 
to see because you know now that a 7 bit integer can contain a value between 0 and 2<sup>7</sup> - 1, or 127. 
What happens when we add 1?</li>
<li>If the integer were unsigned, the next value would be 1 0 0 0 0 0 0 0<sub>2</sub>, 
or 128 (2<sup>7</sup>). But since this is a signed integer, 1 0 0 0 0 0 0 0<sub>2</sub> is a negative value: 
the sign bit 
is 1!</li>
<li>Since this is the case, we must ask the question: what is the decimal value corresponding to the 
signed integer<br>
1 0 0 0 0 0 0 0<sub>2</sub>? To answer this question, we must take the 2's complement of that 
value, by first taking the 1's complement and then adding one.</li>
<li>The 1's complement is 0 1 1 1 1 1 1 1<sub>2</sub>, 
or decimal 127. Since we must now add 1 to that, our conclusion is that the signed integer 
1 0 0 0 0 0 0 0<sub>2</sub> must be equivalent to decimal -128!</li>
</ul>
</blockquote>
<p>
Odd as this may seem, it is in fact the only consistent way to interpret 2's complement signed integers. Let us 
continue now to "count" by adding 1 to 1 0 0 0 0 0 0 0<sub>2</sub>: 
</p><blockquote>
<ul>
<li>1 0 0 0 0 0 0 0<sub>2</sub> + 
0 0 0 0 0 0 0 1<sub>2</sub> is 1 0 0 0 0 0 0 1<sub>2</sub>.</li>
<li>To find the decimal equivalent of 
1 0 0 0 0 0 0 1<sub>2</sub>, we again take the 2's complement: the 1's complement is <br>
0 1 1 1 1 1 1 0<sub>2</sub> 
and adding 1 we get 0 1 1 1 1 1 1 1<sub>2</sub> (127) so 1 0 0 0 0 0 0 1<sub>2</sub>  is equivalent to -127.</li>
<li>We see then that once we have accepted the fact that 1 0 0 0 0 0 0 0<sub>2</sub> is decimal -128, counting 
by adding one works as we would expect.</li><p>
</p><li>Note that the most negative number which we can store in an 8 bit 
signed integer is -128, which is - 2<sup>8 - 1</sup>, and that the largest positive signed integer we can
store in an 8 bit signed integer is 127, which is 2<sup>8 - 1</sup> - 1.</li>
<li>The number of integers between -128 
and + 127 (inclusive) is 256, which is 2<sup>8</sup>; this is the same number of values which an unsigned
8 bit integer can contain (from 0 to 255).</li><p>
</p><li>Eventually we will count all the way up to 1 1 1 1 1 1 1 1<sub>2</sub>. The 1's complement of this number is 
obviously 0, so<br>
1 1 1 1 1 1 1 1<sub>2</sub> must be the decimal equivalent of -1.</li>
</ul>
</blockquote>
Using our deliberations on 
8 bit signed integers as a guide, we come to the following observations about signed integer arithmetic in general:
<blockquote>
<ul>
<li><b>if a signed integer has n bits, it can contain a number between - 2<sup>n - 1</sup> and + (2<sup>n - 1</sup> 
- 1)</b>.</li><p>
</p><li><b>since both signed and unsigned integers of n bits in length can represent 2<sup>n</sup> different values, 
there is no inherent way to distinguish signed integers from unsigned integers simply by looking at them; the 
software designer is responsible for using them correctly</b>.</li><p>
</p><li>no matter what the length, if a signed integer has a binary value of all 1's, it is equal to decimal -1.</li>
</ul></blockquote>
You should verify that a signed short integer can hold decimal values from -32,768 to +32,767, a signed long
integer can contain values from -2,147,483,648 to +2,147,483,647 and a signed double integer can
represent decimal values from -9,223,372,036,854,775,808 to +9,223,372,036,854,775,807.
<p>
 There is an interesting consequence to the fact that in 2's complement arithmetic, one expects to throw away the 
final carry: in unsigned arithmetic a carry out of the most significant digit means that there has been an 
overflow, but in signed arithmetic an overflow is not so easy to detect. In fact, signed arithmetic overflows 
are detected by checking the consistency of the signs of the operands and the final answer. A signed overflow 
has occurred in an addition or subtraction if:
</p><blockquote>
<ul>
<li> the sum of two positive numbers is negative;</li>
<li> the sum of two negative numbers is non-negative;</li>
<li> subtracting a positive number from a negative one yields a positive result; or</li>
<li> subtracting a negative number from a non-negative one yields a negative result.</li>
</ul></blockquote>
<p><a name="fixed">
Integer arithmetic on computers is often called "<b>fixed point</b>" arithmetic and the integers themselves are often 
called fixed point numbers. Real numbers on computers (which may have fractional parts) are often called 
"floating point" numbers, and they are the subject of the </a><a href="http://kias.dyndns.org/comath/14.html">next section</a>.
</p><p>
</p><hr><blockquote><table width="500"><tbody><tr><td>Go to:</td><td><a href="http://kias.dyndns.org/comath/text.html">Title Page</a></td><td><a href="http://kias.dyndns.org/comath/toc.html">Table of Contents</a></td><td><a href="http://kias.dyndns.org/comath/ind.html">Index</a></td></tr></tbody></table></blockquote><hr>
<p>
©2013, Kenneth R. Koehler.  All Rights Reserved. This document may be freely 
reproduced provided that this 
copyright notice is included.</p><p>
Please send comments or suggestions to 
<a href="mailto:kenneth.koehler@uc.edu">the author</a>.


</p></body></html>